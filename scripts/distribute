#!/usr/bin/perl
#!/opt/local/bin/perl
use File::Copy;
use Getopt::Long;
use File::Basename;
use Cwd;
#
# Link file args (relative paths) to model/scripts directories:
#
$remove = 0;
$list = 0;
&GetOptions(
   "model=s"   => \$model,
   "chmod=s"   => \$chmod,
   "remove"    => \$remove,
   "list"      => \$list
) or die usage();
#
# Order of precedence for determining tgcmroot is: 
#   1: Option to this program (-tgcmroot)
#   2: Environment variable $TGCMROOT
#   3: The default directory on hao or scd systems.
#  
$tgcmroot_default_hao = "/home/tgcm";
$tgcmroot_default_scd = "/fis/hao/tgcm";
if (! defined $tgcmroot or $tgcmroot eq "") {
  if (defined $ENV{TGCMROOT}) { $tgcmroot = $ENV{TGCMROOT}; 
    print "\n$0: Using tgcmroot from TGCMROOT env var: $tgcmroot\n";
  } elsif (-d $tgcmroot_default_hao) { $tgcmroot = $tgcmroot_default_hao;
    print "\n$0: Using default tgcmroot at HAO: $tgcmroot\n";
  } elsif (-d $tgcmroot_default_scd) { $tgcmroot = $tgcmroot_default_scd;
    print "\n$0: Using default tgcmroot at SCD: $tgcmroot\n"; 
  } else { 
    die "\n>>> $0: Could not determine tgcmroot (please use -tgcmroot option)\n\n";
  }
}
#
# Arg files are linked to the following directories:
#
@dirs = valid_models($tgcmroot);
foreach $dir (@dirs) {
  $dir = "$tgcmroot/$dir/scripts"; 
}
push (@dirs,"$tgcmroot/bin");

#print "distribute: dirs = \n";
#foreach $dir (@dirs) { print "$dir\n"; }
#exit;

# 
if (! @ARGV and ! $list) { print "\nNo files to distribute??\n"; usage(); }
if (defined $model) { 
  print "Linking only to directories conforming to model $model\n"; }
#
# Just show listings of each directory:
if ($list) {
  print "Doing listings only..\n";
  foreach $dir (@dirs) {
    if (! -d $dir) {
      print "Cannot find directory $dir -- skipping..\n";
      next;
    }
    if (! -d $dir) {
      print "Cannot find directory $dir for listing -- skipping..\n";
      next;
    }
    print "\nContents of directory $dir:\n";
    system("ls -lF $dir");
  }
  exit 1;
}
#
# Loop over file args:
# If file arg does not exist print non-fatal warning.
# If $dir/$file already exists, remove it before linking (fatal if error)
# Any error linking $file to $dir/$file is fatal.
#
while ($file = shift(@ARGV)) {
  if (! -e $file and ! $remove) {       # file arg does not exist -- non-fatal
    print ">>> Cannot find file $file\n"; 
  } else {
    foreach $dir (@dirs) {
      if (! -d $dir) {
        print "Cannot find directory $dir -- skipping..\n";
        next;
      }
#
# Do not distribute if $model arg was provided and current dir does not match:
      if (defined $model) {
        if ($dir !~ /$model/) { 
#         print "Not distributing to $dir because it does not match model $model\n";
          next; 
        }
      }
#
# Link to scripts subdirectory:
      $scriptsdir = "$dir";
      if (! -d $scriptsdir) {
        print "Cannot find scripts directory $scriptsdir -- skipping..\n";
        next;
      }
#
# Remove instead of distribute, if requested:
      if ($remove) {
        if (-e "$scriptsdir/$file") {    # remove pre-existing link in dir
          $stat = unlink("$scriptsdir/$file") || die "Error from unlink of $scriptsdir/$file\n\n";
          print "Removed $scriptsdir/$file\n";
        } else {
          print "Could not find file $scriptsdir/$file for remove..\n";
        }
        next;
      }
#
# Distribute to current scripts dir:
      if (-e "$scriptsdir/$file") {    # remove pre-existing link in dir
        unlink("$scriptsdir/$file") || die "Error removing $scriptsdir/$file\n"; }
      link("$file","$scriptsdir/$file") || 
        die "Error linking $file to $scriptsdir/$file\n";
      if (defined $chmod) {
        chmod(oct($chmod),"$scriptsdir/$file") || 
          die "Error from chmod $chmod $scriptsdir/$file\n";
        print "Linked $file to $scriptsdir/$file (with chmod $chmod)\n";
      } else {
        print "Linked $file to $scriptsdir/$file\n";
      }
    } # each dir
  } # file existence
} # while args

#-------------------------------------------------------------------------
sub usage {
  die <<EOF;

SYNOPSIS
  $0 [options] file1 [file2,file3,...]

DESCRIPTION
  Link given files to directories.

OPTIONS
  -model=model 	Distribute only to directories beginning with the string model
  -chmod=chmod  Do chmod on file after linking 
  -remove	Remove (unlink) files rather than distributing
  -list         Only list files in each scripts directory (file args are ignored)

EOF
}
#-----------------------------------------------------------------------
sub valid_models {
#
# List valid models found in $tgcmroot (uses sub validate_model above):
#
  my ($tgcmroot) = @_;
  my $mycwd = cwd();
  $progname = $0;
  if (! -d $tgcmroot) {
    die "\n$progname: >>> Tgcmroot $tgcmroot does not exist as a directory.\n";
  }
  chdir($tgcmroot) || 
    die "\n$progname: >>> Could not chdir to tgcmroot $tgcmroot\n";
  @list = `/bin/ls` ; chomp @list;
  foreach $file (@list) { 
    if (validate_model($tgcmroot,$file)) { push(@valid,$file); }
  }
  if (@valid) {
    print "\nList of valid models under tgcmroot $tgcmroot:\n";
    print "@valid\n\n";
  } else {
    print ">>> Could not find any valid model directories under tgcmroot $tgcmroot\n";
  }
  chdir($mycwd);
  return @valid;
}
#-----------------------------------------------------------------------
sub validate_model {
#
# Return 1 if $tgcmroot/$model is valid, return 0 otherwise.
# A model is valid if the directory $tgcmroot/$model exists and
#   contains both src/ and scripts/ subdirectories.
#
  my ($tgcmroot,$model) = @_;
  if (-d "$tgcmroot/$model/src" and -d "$tgcmroot/$model/scripts") { 
    return 1;
  } 
  return 0;
}
