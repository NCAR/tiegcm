#!/usr/bin/perl
#
# TGCM configure script.
#
use Getopt::Long;
use IO::File;
use File::Copy;
use File::Basename;
use Cwd;
#
$cwd = cwd();
($progname = $0) =~ s!(.*)/!!;
#
# Set option defaults (local):
#
my $wrkdir      = $cwd;        # user's root working dir (default is cwd)
my $copysrc     = 0;           # default is not to copy source
my $hres        = 5.0;         # default horizontal resolution
my $vres        = 0.5;         # default vertical resolution
my $debug       = 0;           # default is no debug run
my $nomake      = 0;           # default is to make a Makefile
my $help        = 0;           # default is no help
#
# Parse arguments:
#
&GetOptions(
   "model=s"        => \$model,
   "wrkdir=s"       => \$wrkdir,
   "usr_srcdirs:s"  => \$usr_srcdirs,
   "execdir:s"      => \$execdir,
   "tgcmroot:s"     => \$tgcmroot,
   "tgcmdata:s"     => \$tgcmdata,
   "utildir:s"      => \$utildir,
   "copysrc!"       => \$copysrc,
   "hres=f"         => \$hres,
   "vres=f"         => \$vres,
   "debug"          => \$debug,
   "nomake"         => \$nomake,
   "h|help"         => \$help,
) or usage();
#
# Provide usage statement for help:
if ($help) { usage(); } # provide usage if help was requested
#
# Check for unparsed arguments:
if (@ARGV) {
    print "ERROR: unrecognized arguments: @ARGV\n";
    usage();
}
#
# Default tgcmroot at hao and scd:
#
$tgcmroot_default_hao = "/home/tgcm";
$tgcmroot_default_scd = "/fis/hao/tgcm";
#
#
# Validate args:
&validate_options();
#
# Report options to stdout:
#
$date = `date`; chop($date);
print << "EOF";

$progname executing in $cwd at $date:
  model       = $model
  wrkdir      = $wrkdir
  usr_srcdirs = $usr_srcdirs
  execdir     = $execdir
  tgcmroot    = $tgcmroot
  tgcmdata    = $tgcmdata
  utildir     = $utildir
  copysrc     = $copysrc
  hres        = $hres
  vres        = $vres
  debug       = $debug

EOF
#
# Model source directory:
#
$model_srcdir = "$tgcmroot/$model/src";
if (! -d $model_srcdir) { 
  print ">>> WARNING $progname: could not find source directory $model_srcdir\n"; }
#
# Model scripts directory:
#
$model_scripts = "$tgcmroot/$model/scripts";
if (defined $utildir) { $model_scripts = $utildir; }
if (! -d $model_scripts) {
  print ">>> WARNING $progname: could not find scripts directory $model_srcdir\n"; }
#
#print "Using model source directory model_srcdir   = $model_srcdir\n";
#print "Using model scripts directory model_scripts = $model_scripts\n";
#
# Model class:
$model_class = "tgcm";
SWITCH: {
  if ($model =~ /^tiegcm/)  { $model_class = "tiegcm" ; last SWITCH; }
  if ($model =~ /^timegcm/) { $model_class = "timegcm"; last SWITCH; }
  if ($model =~ /^mtgcm/)   { $model_class = "mtgcm"  ; last SWITCH; }
  if ($model =~ /^titan/)   { $model_class = "titan"  ; last SWITCH; }
}
#
# Build list of source directories and write list to file $execdir/$fp_filename:
#
$fp_filename = "Filepath";
@srcdirs = write_filepath($usr_srcdirs, $model_srcdir, "$execdir/$fp_filename");
#
# Copy needed scripts to execdir:
#
&copy_scripts($model_scripts, $execdir);
#
# Copy source code if requested:
#
if ($copysrc) { &copy_model_src(@srcdirs, $execdir); }
#
# Make defs.h according to given model and resolution:
# (a copy may or may not already exist)
#
&write_defs_h("$execdir/defs.h",$hres,$vres,$model);
#
# Establish source history file names (to be linked by link_model_data):
#
&set_hist_source($model_class,$hres,$vres);
#
# Link input data files to execdir:
#
#print "config before -d test on tgcmdata..\n";
if (-d $tgcmdata) {
  &link_model_data($tgcmdata, $execdir, $model);
} else {
  print ">>> $0: Not linking data files because tgcmdata directory\n";
  print "        $tgcmdata does not exist\n";
}
#
# Write macros to Makefile:
#
if ($nomake) {
  print "$progname: Not making Makefile because -nomake option was set.\n";
} else {
  &write_makefile("$model_scripts/Makefile", "$execdir/Makefile", $debug);
}
#
# Successful exit:
#
$date = `date`; print "\n$0 done at $date\n";
exit;
#
#-------------------------------------------------------------------------
sub usage {
  die <<EOF;

SYNOPSIS
  $0 [options]
OPTIONS
  -model	Name of requested model (usually begins with "tiegcm" or "timegcm").
  -wrkdir	Top directory for job (default is current directory)
  -usr_srcdirs	Optional list directories containing user-provided source code
                (Comma-separated list with no imbedded whitespace).
  -execdir	Build/Execution directory (default \$wrkdir/\$model-\$os)
  -tgcmroot  	TGCM root distribution (default \$TGCMROOT).
  -tgcmdata  	TGCM root distribution of model data (default \$TGCMDATA). 
  -utildir   	Directory containing tgcm_config and other utility scripts.
                (default based on tgcmroot)
  -copysrc      If copysrc=1, copy source code to build dir (default is 0)
  -hres         Horizontal resolution (float, either 5.0 or 2.5 degrees)
  -vres         Vertical resolution (float, either 0.5 or 0.25 delta log pressure)
  -debug	Configure Makefile for a debug run.
  -help		Print usage message and quit.

EOF
}
#-----------------------------------------------------------------------
sub set_hist_source {
#
# Set default source history file name given model class and grid resolution:
# ($modelclass is the model name without extension)
# If this file exists in $TGCMDATA, it will be linked to users execdir
#   by sub link_model_data.
# For model classes tiegcm, timegcm or tgcm (i.e., unrecognized model name), 
#   the file name should resolve to one of the following:
#
#   TGCM.$modelclass.p001-2002-080.nc            # default hres, default vres
#   TGCM.$modelclass_h5.0v0.25.p001-2002-080.nc  # default hres, double vres
#   TGCM.$modelclass_h2.5v0.50.p001-2002-080.nc  # double hres, default vres
#   TGCM.$modelclass_h2.5v0.25.p001-2002-080.nc  # double hres, double vres
#
  my ($modelclass,$hres,$vres) = @_;
#
# Four dates should be available (one for each solstice and equinox).
# Use day 80 as default:
#
  my @dates = ("2002-080","2002-170","2002-260","2002-350");
  my $filename = "p001-$dates[0].nc"; # use default day 80
#
# Source history file name for default hres and vres:
#
  $hist_source = "TGCM.$modelclass.$filename";
  $hist_source_mss = "/TGCM/$modelclass/$filename";
#
# Source history file name for non-default grid resolutions hres or vres:
# (make string equiv of hres and vres, so zeroes are consistent in file name):
#
  if ($hres != 5.0 or $vres != 0.5) {
    if ($hres == 5.0)  { $hresname = "5.0" ; }
    if ($hres == 2.5)  { $hresname = "2.5" ; }
    if ($vres == 0.50) { $vresname = "0.50"; }
    if ($vres == 0.25) { $vresname = "0.25"; }
    $hist_source = "TGCM.$modelclass" . "_h$hresname" . "v$vresname" . ".$filename";
    $hist_source_mss = 
      "/TGCM/$modelclass" . "_h$hresname" . "v$vresname" . "/$filename";
  }
#
# Odd models (i.e., not tiegcm or timegcm):
  if ($modelclass eq "mtgcm") { 
    $hist_source = "TGCM.SWBM04.p1DC98RSb.nc";
    $hist_source_mss = "/TGCM/SWBM04/p1DC98RSb.nc";
  }

  print "\nDefault source history disk file name: $hist_source\n";
  print "Default source history mss file: $hist_source_mss\n";
}
#-----------------------------------------------------------------------
sub validate_options {
#
# Validate (possible modify) user options (globals, not local).
  print "\n";
#
# -model option is required:
#
  if (! defined $model or $model eq "") {
    print "\n>>> $progname: Please provide the name of the desired model using the -model option.\n";
    usage();
  } 
#
# Working directory: default is cwd, otherwise make it if necessary:
#
  if (! defined $wrkdir or $wrkdir eq "") {
    $wrkdir = abspath(".");
#   print "$progname: Using wrkdir = $wrkdir\n";
  } else {
    $wrkdir = abspath($wrkdir);
    if (! -d $wrkdir) {
      mkdir($wrkdir, 0777) || \
        die "\n>>> $progname: Could not make wrkdir directory $wrkdir\n\n";
      print "Made new wrkdir directory $wrkdir\n";
    } else { 
#     print "Using already existing wrkdir $wrkdir\n"; 
    }
  }
#
# User source directories (optional, but must exist if provided):
#
  if (defined $usr_srcdirs) {
    if ($usr_srcdirs eq '') { 
      undef $srcdir; 
    } else {
      my @dirs = split(',', $usr_srcdirs);
      my @paths;
      while (my $dir = shift @dirs) {
        if (-d $dir) { 
          push(@paths, abspath($dir)); 
        } else {
          die "\n>>> $progname: Cannot find user source directory $dir\n";
        }
      }
      $usr_srcdirs = join(',', @paths);
#     print "$progname: usr_srcdirs = $usr_srcdirs\n";
    }
  }
#
# Build/Execution directory (default is $wrkdir/$model-$os):
# (If Linux and machine is lightning, set OS to linux-mpi)
#
  $OS = `uname -s`; chop $OS; 
  if ($OS =~ 'Linux') {
    $nodename = `uname -n`; chop $nodename;
    if ($nodename =~ /^ln/) { $OS = $OS . '-mpi'; }
  }
  ($os = $OS) =~ tr/A-Z/a-z/;
#
  if (! defined $execdir or $execdir eq "") {
    $execdir = "$wrkdir/$model-$os"; # default
    print "$progname: OS=$OS  Set execdir = $execdir\n";
  }
  $execdir = abspath($execdir);
  if (! -d $execdir) {
    mkdir($execdir, 0777) || \
      die "\n>>> $progname: Could not make execdir directory $execdir\n\n";
  }
#
# Determine tgcm root directory $tgcmroot, in the following search order:
#   1) Config option -tgcmroot
#   2) Environment variable $TGCMROOT
#   3) The default HAO directory, if it exists ($tgcmroot_default_hao)
#   4) The default SCD directory, if it exists ($tgcmroot_default_scd)
# If this search fails, quit with an error message explaining tgcmroot.
#
  if (! defined $tgcmroot or $tgcmroot eq "") {
    if (defined $ENV{TGCMROOT}) { 
      $tgcmroot = $ENV{TGCMROOT}; 
      print "$progname: Set tgcmroot from TGCMROOT env var: $tgcmroot\n";
    } elsif (-d $tgcmroot_default_hao) {
      $tgcmroot = $tgcmroot_default_hao;
      print "$progname: Set tgcmroot to default HAO tgcmroot: $tgcmroot\n";
    } elsif (-d $tgcmroot_default_scd) {
      $tgcmroot = $tgcmroot_default_scd;
      print "$progname: Set tgcmroot to default SCD tgcmroot: $tgcmroot\n";
    } else {
      die <<EOF;

>>> $progname: tgcmroot option not set, and TGCMROOT env var not set.

  To set tgcmroot, please do one of the following:
    1. Use the -tgcmroot option to tgcm_config.
    2. Set the tgcmroot shell variable in your job script that called tgcm_config.
    3. Set the environment variable TGCMROOT in your ~/.cshrc file
       (or from the command line if it is not set in your ~/.cshrc file)

  If configuring the model at HAO you can set tgcmroot to "$tgcmroot_default_hao".
  If configuring the model at SCD you can set tgcmroot to "$tgcmroot_default_scd".

  If you downloaded or otherwise obtained a tar file, set the tgcmroot 
    shell variable in your job script to the directory in which you 
    extracted the tar file.

  The tgcmroot directory should contain a subdirectory with the name of
  the requested model. The model subdirectory in turn should contain the 
  subdirectories src/ and scripts/.

EOF
    }
  }
  $tgcmroot = abspath($tgcmroot);
  if (! -d $tgcmroot) {
    die "\n>>> Cannot find tgcmroot directory $tgcmroot\n\n"; } 
#
# tgcm data directory (non-fatal if not defined or does not exist)
# If option not set and env var TGCMDATA is not set, use $execdir.
#
  if (! defined $tgcmdata or $tgcmdata eq "") {
    if (defined $ENV{TGCMDATA}) { 
      $tgcmdata = $ENV{TGCMDATA}; 
      print "$progname: Set tgcmdata from TGCMDATA env var: $tgcmdata\n";
    } else {
      print "$progname: Set tgcmdata directory to execdir $execdir\n";
      $tgcmdata = $execdir;
    }
  }
  $tgcmdata = abspath($tgcmdata);
  if (! -d $tgcmdata) {
    print "\n>>> WARNING: Cannot find tgcmdata directory $tgcmdata\n\n"; } 
#
# If utildir was provided, it must exist. If not provided, will default
# to scripts directory based on $tgcmroot (see above, after validation).
#
  if (defined $utildir) {
    if (! -d $utildir) {
      die "\n>>> $progname: utility directory $utildir does not exist.\n\n";
    }
  }
#
# Horizontal and Vertical resolution requests:
  if ($hres != 5.0 &&  $hres != 2.5) {
    print "\n>>> Bad hres = $hres (hres must be either 5.0 or 2.5 degrees)\n\n";
    usage();
  }
  if ($vres != 0.5 &&  $vres != 0.25) {
    print "\n>>> Bad vres = $vres (vres must be either 0.5 or 0.25)\n\n";
    usage();
  }
} # end sub validate_options
#-----------------------------------------------------------------------
sub abspath {
#
# Convert a pathname into an absolute pathname, expanding any . or .. characters.
# Assumes pathnames refer to a local filesystem.
# Assumes the directory separator is "/".
#
  my ($path) = @_;
  my $cwd = getcwd();  # current working directory
  my $abspath;         # resulting absolute pathname
#
# Strip off any leading or trailing whitespace.  
# (This pattern won't match if there's embedded whitespace.
#
  $path =~ s!^\s*(\S*)\s*$!$1!;
#
# Convert relative to absolute path.
#
  if ($path =~ m!^\.$!) {          # path is "."
      return $cwd;
  } elsif ($path =~ m!^\./!) {     # path starts with "./"
      $path =~ s!^\.!$cwd!;
  } elsif ($path =~ m!^\.\.$!) {   # path is ".."
      $path = "$cwd/..";
  } elsif ($path =~ m!^\.\./!) {   # path starts with "../"
      $path = "$cwd/$path";
  } elsif ($path =~ m!^[^/]!) {    # path starts with non-slash character
      $path = "$cwd/$path";
  }
  my ($dir, @dirs2);
#
# The -1 prevents split from stripping trailing nulls
# This enables correct processing of the input "/".
#
  my @dirs = split "/", $path, -1;   

  my $i;
  # Remove any "" that are not leading.
  for ($i=0; $i<=$#dirs; ++$i) {
      if ($i == 0 or $dirs[$i] ne "") {
          push @dirs2, $dirs[$i];
      }  
  }
  @dirs = ();

  # Remove any "."
  foreach $dir (@dirs2) {
      unless ($dir eq ".") {
          push @dirs, $dir;
      }  
  }
  @dirs2 = ();

  # Remove the "subdir/.." parts.
  foreach $dir (@dirs) {
    if ( $dir !~ /^\.\.$/ ) {
        push @dirs2, $dir;
    } else {
        pop @dirs2;   # remove previous dir when current dir is ..
    }
  }  
  if ($#dirs2 == 0 and $dirs2[0] eq "") { return "/"; }
  $abspath = join '/', @dirs2;
  return( $abspath );
}
#-----------------------------------------------------------------------
sub fullpath {
#
# Get full path to relative $path by cd'ing to $path and doing a pwd.
# (this will fail if $path does not exist)
#
  my ($path) = @_;
  my $mycwd = cwd();
  my ($basename, $dirname, $suffix) = fileparse($path);
  if (! -d $dirname) { die "\n>>> fullpath: Directory $dirname does not exist\n"; }
  chdir($dirname) || die "\n>>> fullpath: Cannot cd to $dirname\n";
  $fulldir = cwd(); 
  chdir($mycwd);
  $fullpath = $fulldir . '/' . $basename;
  $fullpath =~ s/\.$//;     # remove trailing "."
  $fullpath =~ s/\/$//;     # remove trailing "/"
  $fullpath =~ s/^\/\//\//; # replace two leading slashes with one
  return $fullpath;
}
#-----------------------------------------------------------------------
sub copy_model_src {
#
# Copy source code to build directory:
#
  my (@dirlist) = @_;
  my $blddir = pop(@dirlist);
#
# Note source is copied from reversed dirlist. This is so model code
# is copied first, and is then overwritten with any user code.
#
  foreach $dir (reverse @dirlist) {
    my @files = (glob("$dir/*.[Fc]"), glob("$dir/*.F90"));
    if (($nfiles = $#files) >= 0) { 
      $nfiles = $nfiles + 1;
      foreach $file (@files) {
        my $stat = copy($file,$blddir);
        if ($stat != 1) { 
          print ">>> WARNING: Error copying source file $file to $dir\n"; }
      }
      print "Copied $nfiles source files from $dir\n";
    } else {
      print ">>> WARNING: No source files found in directory $dir\n";
    }
  }
}
#-------------------------------------------------------------------------
sub write_defs_h {
#
# Write new $file (defs.h) for given model and resolution:
#
  my ($file, $hres, $vres, $model) = @_;
#
# Grids for timegcm:
#
if ($model =~ /^timegcm/) {
#
# Standard resolution for timegcm:
  $nlat=36; $glat1="-87.5" ; $dlat="5.0";
  $nlon=72; $glon1="-180.0"; $dlon="5.0"; 
  $nlev=44; $zbot ="-17.0" ; $ztop="5.0";
#
# Double horizontal res for timegcm:
  if ($hres == 2.5) {
    $nlat=72 ; $glat1="-88.75"; $dlat="2.5";
    $nlon=144; $glon1="-180.0"; $dlon="2.5"; 
  }
#
# Double vertical res for timegcm:
  if ($vres == 0.25) { 
    $nlev=88; $zbot ="-17.0"; $ztop="5.0";
  }
#
# Grids for tiegcm:
#
} elsif ($model =~ /^tiegcm/) {
#
# Standard resolution for tiegcm:
  $nlat=36; $glat1="-87.5" ; $dlat="5.0";
  $nlon=72; $glon1="-180.0"; $dlon="5.0"; 
  $nlev=28; $zbot ="-7.0"  ; $ztop="7.0";
#
# Double horizontal res for tiegcm:
  if ($hres == 2.5) {
    $nlat=72 ; $glat1="-88.75"; $dlat="2.5";
    $nlon=144; $glon1="-180.0"; $dlon="2.5"; 
  }
#
# Double vertical res for tiegcm:
  if ($vres == 0.25) { 
    $nlev=56; $zbot ="-7.0"; $ztop="7.0";
  }
#
# Unrecognized model:
} else {
  print ">>> Model name $model not recognized -- NOT making header file $file\n";
  return;
}
#
# If file exists, check to see if it is already set for the desired resolution:
#
  if (-e $file) {
    my $fh = new IO::File;
    $fh->open("<$file") || die ">>> can't open header file: $file\n";
    while (<$fh>) { 
      if (/NLAT\s+\((\S+)\)/) { $nlat_rd = $1 };
      if (/NLON\s+\((\S+)\)/) { $nlon_rd = $1 };
      if (/NLEV\s+\((\S+)\)/) { $nlev_rd = $1 };
    }
    $fh->close;
    if ($nlat_rd == $nlat &&
        $nlon_rd == $nlon &&
        $nlev_rd == $nlev) {
      print "NOT writing new defs.h for $model because it is already set for\n";
      print "  the desired resolution of hres=$hres  vres=$vres (nlat=$nlat nlon=$nlon nlev=$nlev)\n";
      return;
    }
  }
#
# Write new file:
#
  print "Making header file $file\n  for hres=$hres vres=$vres\n";
  my $fh = new IO::File;
  $fh->open(">$file") || die ">>> can't open header file: $file\n";
  $date = `date`; chop($date);
  print $fh <<"EOF";
!
! Grid parameters definitions for $model (see params.F).
! Horizontal resolution = $hres  Vertical resolution = $vres
!
! hres = $hres
#define NLAT  ($nlat)
#define GLAT1 ($glat1)
#define DLAT  ($dlat)
!
! hres = $hres
#define NLON  ($nlon)
#define GLON1 ($glon1)
#define DLON  ($dlon)
!
! vres = $vres
#define ZBOT ($zbot)
#define ZTOP ($ztop)
#define NLEV ($nlev)
!
! This file was generated by $progname on $date
!
EOF
}  # end sub write_defs_h
#-----------------------------------------------------------------------
  sub link_model_data {
#
# Link input data files from $datadir (TGCMDATA) to $execdir
# (do not link if file already exists in $execdir):
#
  my ($datadir, $execdir, $model) = @_;
#
# Set data file names for model and resolution.
#
# History source file was determined by sub set_hist_source according
#   to model and grid resolutions. Some other file names (notably gswm) 
#   need to be hardwired according to model and resolution:
#
# Data files for tiegcm:
#
  if ($model =~ /^tiegcm/) {
    %data = (gswm_mdi_ncfile    => "gswm_diurn_5.0d_99km.nc" ,  # 24  MB
             gswm_msdi_ncfile   => "gswm_semi_5.0d_99km.nc"  ,  # 24  MB
             gswm_nmidi_ncfile  => "gswm_nonmig_diurn_5.0d_99km.nc",
             gswm_nmisdi_ncfile => "gswm_nonmig_semi_5.0d_99km.nc" ,
             magfield_file      => "magfield.nc"             ,  # ~1  MB
             gpi_file           => "gpi_1979001-2005059.nc"  ,  # 0.7 MB
             sd_file            => "see__L3_merged_2005007_007.nc"  ,  # 336 KB
             hist_source        => $hist_source);
#
# High hres tiegcm:
    if ($hres == 2.5) {
      $data{"gswm_mdi_ncfile"}    = "gswm_diurn_2.5d_99km.nc";          # 95  MB
      $data{"gswm_msdi_ncfile"}   = "gswm_semi_2.5d_99km.nc";           # 95  MB
      $data{"gswm_nmidi_ncfile"}  = "gswm_nonmig_diurn_2.5d_99km.nc";
      $data{"gswm_nmisdi_ncfile"} = "gswm_nonmig_semi_2.5d_99km.nc";
      $data{"magfield_file"}      = "magfield_2.5h.nc";                 # 2.8 MB
    } 
#
# Data files for timegcm:
#
  } elsif ($model =~ /^timegcm/) {
    %data = (solgar_bndry_file    => "solgar_bndry.nc"          , # 92  KB
             solgar_import_file   => "solgar_import.nc"         , # 0.5 MB
             zatmos_file          => "zatmos_bndry.nc"          , # 0.3 MB
             gswm_mdi_ncfile      => "gswm_diurn_5.0d_32km.nc"  , # 24  MB
             gswm_msdi_ncfile     => "gswm_semi_5.0d_32km.nc"   , # 24  MB
             gswm_nmidi_ncfile    => "gswm_nonmig_diurn_5.0d_32km.nc",
             gswm_nmisdi_ncfile   => "gswm_nonmig_semi_5.0d_32km.nc" ,
             gpi_file             => "gpi_1979001-2005059.nc"   , # 0.7 MB
             ncep_file            => "ncep_1979001-2005120.nc"  , # 409 MB
             hist_source          => $hist_source);
#
# High hres for timegcm:
    if ($hres == 2.5) {
      $data{"gswm_mdi_ncfile"}    = "gswm_diurn_2.5d_32km.nc";          # 95 MB
      $data{"gswm_msdi_ncfile"}   = "gswm_semi_2.5d_32km.nc";           # 95 MB
      $data{"gswm_nmidi_ncfile"}  = "gswm_nonmig_diurn_2.5d_32km.nc";
      $data{"gswm_nmisdi_ncfile"} = "gswm_nonmig_semi_2.5d_32km.nc";
    } 
#
# Data files for mtgcm:
  } elsif ($model =~ /^mtgcm/) {
    %data = (datavol       => "TGCM.SWBM04.MLVI090c.nc",           # 4.3  MB
             hist_source   => $hist_source);
#
# Old tgcm24 version of timegcm:
  } elsif ($model =~ /^tgcm24/) {
    %data = (hist_source => "TGCM.timegcm.p001-2002-080.nc");
#
# Unknown model:
  } else {
    print "\n>>> WARNING: Unknown model type: $model\n";
    print   "             Not linking any input data files.\n";
  }
#
# Loop over data files, linking to user's execdir:
# (Failed links are non-fatal, but a warning message is issued)
# Wildcards in %data are expanded using glob (not currently necessary)
#
  @data_files = values(%data);
  foreach $filespec (@data_files) {
    @paths = glob "$datadir/$filespec"; # expands wildcards in data_files
    foreach $path (@paths) {
      $file = basename($path);

#     print "\nlink data: file=$file\n";
#     print "           path=$path\n";
#     print "           execdir=$execdir\n";

      if (-e $path) {                  # path to data file found in distribution
        if (! -e "$execdir/$file") {   # data file not in user exec dir
#
# Link from $datadir (TGCMDATA) to user's execdir:
#
          $stat = symlink($path,"$execdir/$file");        # perl symlink
          if ($stat != 1) {
            print ">>> Error linking $path to $execdir\n";
          } else { 
            print "Linked data file $path to $execdir\n"; 
          }
#       } else { print "Did NOT link $path to because it already exists in execdir.\n";
        }         # if data is not in user's execdir
      } else {    # data not found in distribution
        print ">>> Could not find data file $path\n"; 
      }           # if data file exists in distribution
    }             # foreach path in @paths
  }               # foreach filespec in %data
} # end sub link_model_data
#-----------------------------------------------------------------------
sub copy_scripts {
#
# Copy Makefile, MakeDepends, and MakeLogs from scripts dir to build dir:
# Make all but Makefile executable.
#
  my ($scriptsdir, $blddir) = @_;
  my @scripts = ("MkSrcfiles","MkDepends","MkDispose","MkLogs","MkNamelist");
  foreach $script (@scripts) {
    $stat = copy("$scriptsdir/$script","$blddir");
    if ($stat != 1) { 
      print ">>> WARNING: Error copying $scriptsdir/$script to $blddir\n"; 
    } else {
      print "Copied $script to $blddir\n";
      chmod(0755, "$blddir/$script") ||
        die ">>> Error from chmod 0755 $blddir/$script\n";
    }
  }
}
#-----------------------------------------------------------------------
sub write_filepath {
  my ($usr_srcdirs, $model_srcdir, $fileout) = @_;
  my $fh = new IO::File;
  $fh->open(">$fileout") or die "$progname: Can't open filepath file: $fileout\n";
  print "Writing source directory list to file $fileout.\n";
#
# User source directories (they are currently a comma-separated list
# without white space):
#
  @dirs = ();
  if ($usr_srcdirs =~ /\S+/) {
    @dirs = split(',',$usr_srcdirs);
    foreach $dir (@dirs) {
      print $fh "$dir\n";
      print "  User source directory: $dir\n";
    }
  }
#
# Add model directory:
#
  print $fh "$model_srcdir\n";
  print "  Model source directory: $model_srcdir\n";
  push(@dirs,$model_srcdir);
#
  $fh->close;
  return @dirs;
}
#-----------------------------------------------------------------------
sub write_makefile {
#
# Write macros to Makefile:
#
  my ($file_in, $file_out, $debugarg) = @_;
  my $fh_in = new IO::File;
  my $fh_out = new IO::File;
  $fh_out->open(">$file_out") or die ">>> Can't open file: $file_out\n";
  $date = `date`; chop($date);
  $OS = `uname -s`; chop $OS; ($os = $OS) =~ tr/A-Z/a-z/;
  SWITCH: {
    if ($os eq "aix") { 
      $lib_netcdf = "/usr/local/lib32/r4i4";
      $inc_netcdf = "/usr/local/include";
      last SWITCH;
    }
    if ($os eq "irix64") { 
      $lib_netcdf = "/usr/local/lib32/r4i4";
      $inc_netcdf = "/usr/local/include";
      last SWITCH;
    }
    if ($os eq "linux") { 
#
# Distinguish between SCD linux system "lightning", and
# other (hao) linux systems, using the node name.
# If lightning, then set OS to linux-mpi.
#
      $nodename = `uname -n`; chop $nodename;
      if ($nodename =~ /^ln/) {              # SCD linux cluster "lightning"
        $OS = $OS . '-mpi';
#       $lib_netcdf = "/usr/local/lib";
#       $inc_netcdf = "/usr/local/include";
# 7/21/05 btf: new netcdf locations on lightning after OS upgrade:
        $lib_netcdf = "/usr/local/netcdf/3.5.1-pgi5.2-64/lib";
        $inc_netcdf = "/usr/local/netcdf/3.5.1-pgi5.2-64/include";
      } else {                               # Generic linux (probably HAO)
        $lib_netcdf = "/opt/local/rh9/lib";
        $inc_netcdf = "/opt/local/include";
      }
      last SWITCH;
    }
    $nothing = 1;
  }
  print "write_makefile: OS=$OS lib_netcdf=$lib_netcdf inc_netcdf=$inc_netcdf\n";
#
  $mkdebug = "FALSE";
  if ($debugarg) {
    $mkdebug = "TRUE";
#   print "Writing Makefile for debug run..\n";
  }
#
# Write macros to top of output Makefile:
#
  print $fh_out <<"EOF";
#
# Macros for model $model, written by $progname at $date
#
UNAMES     := $OS
EXECNAME   := $model
EXECDIR    := $execdir
LIB_NETCDF := $lib_netcdf
INC_NETCDF := $inc_netcdf
DEBUG      := $mkdebug
EOF
#
# Copy template and close files:
#
  $fh_in->open("<$file_in") or die "Can't open file: $file_in\n";
  while (<$fh_in>) { print $fh_out $_; }
  $fh_out->close;
  $fh_in->close;
  print "\nWrote Makefile $file_out:\n";
  print << "EOF";
    UNAMES     := $OS
    EXECNAME   := $model
    EXECDIR    := $execdir
    LIB_NETCDF := $lib_netcdf
    INC_NETCDF := $inc_netcdf
    DEBUG      := $mkdebug

EOF
}
